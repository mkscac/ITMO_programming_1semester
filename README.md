# ITMO_programming_1semester

***Laboratory work on the subject "Fundamentals of programming" at ITMO University for 1 semester. All tasks were completed in C.***



### ___1. Archiver___


**ТЗ**

Архиватор должен:

- Уметь архивировать несколько (один и более) указанных файлов в архив с расширением *.arc
- Уметь распаковывать файловых архив, извлекая изначально запакованные файлы
- Предоставлять список файлов, упакованных в архиве
- Архиватор должен быть выполнен в виде консольного приложения, принимающего в качестве аргументов следующий параметры 

--file FILE Имя файлового архива, с которым будет работать архиватор • --create Команда для создания файлового архива • --extract; Команда для извлечения из файлового архива файлов • --list Команда для предоставления списка файлов, хранящихся в архиве • FILE1 FILE2 .... FILEN Свободные аргументы для передачи списка файлов для запаковки

Примеры использования: 
arc --file data.arc --create a.txt b.bin c.bmp 
arc --file data.arc --extract 
arc --file data.arc --list



**Решение с комментарием**

При вводе команды --file мы задаем имя файлового архива и сохраняем его в main. Название будет находится в argv[i+1] – далее мы с ним работает всю программу.

Команда -- create соответствует функции Create_fileArchive. Данная функция принимает на вход название архива, с которым будет проиcходить работа, массив с файлами и количество файлов. Далее отрывается архив с помощью команды fopen() c wb – режим создания пустого файла для записи. Работа будет происходить с бинарными файлами (b). Далее с помощью чтения считываем все файлы и помещаем их в архив. Используются следующие функции: • fseek устанавливает позицию в потоке данных, заданным аргументом stream. Относительно установленной позиции будет осуществляться чтение и запись данных. • SEEK_END – смещение отсчитывается от конца файла • ftell определяет текущую позицию в потоке данных, на который указывает аргумент stream. • rewind устанавливает текущую позицию для чтения/записи файла, связанного с потоком данных, на который указывает аргумент stream, в начало файла и сбрасывает индикатор ошибок потока данных. • fwrite предназначена для записи данных из массива.

Команда --extract соответствует функции Extract_fileArchive. Мы также открываем архив, только на сей раз для чтения. Пока не конец файла выполняем следующие действия: считываем данные из файла в массив; выделяем память malloc`ом и записываем в эту переменную текст данного файла из архива; создаем массив символов и записываем в него данные и создаем файл с названием file_1. Используются следующие функции: • feof - проверяет наличие установленного признака конца файла. • sprintf - записывает данные в строку

Команда --list соответствует функции List_fileArchive. Данная функция отрывает архив и пока не дошли до конца файлового архива выводим файлы, которые хранятся в архиве: изначальное название файла и его размер. После выполнения каждой функции необходимо закрывать каждый открытый файл, чтобы избежать утечки данных.


---
### ___2. BMP - game "Life"___


**ТЗ**

Целью лабораторной работы является реализация игры “Жизнь” , позволяющая выводить поколение игры в монохромную картинку в формате BMP. Плоскость “вселенной” игры ограничена положительными координатами.

Лабораторная работа должна быть выполнена в виде консольного приложения принимающего в качестве аргументов следующие параметры:
- --input input_file.bmp 
Где input_file.bmp - монохромная картинка в формате bmp, хранящая начальную ситуация (первое поколение) игры

- --output dir_name 
Название директории для хранения поколений игры в виде монохромной картинки

- --max_iter N
Максимальное число поколений которое может эмулировать программа. Необязательный параметр, по-умолчанию бесконечность

- --dump_freq N
Частота, с которой программа должно сохранять поколения виде картинки. Необязательный параметр, по-умолчанию равен 1




**Решение с комментарием**

В структуре храним параметры нашей bmp картинки.

Функция countNeighbors подсчитывает количество соседних клеток с заданными координатами (x, y) в двумерном массиве grid. Она проходит по каждой соседней клетке и суммирует значение в каждой из них. Если значение в клетке с заданными координатами равно 1 (не черный цвет), то оно исключается из подсчета, чтобы не учитывать саму клетку в сумме. Возвращается общая сумма соседних клеток.

Функция convert_to_bmp преобразует двумерный массив matrix, представляющий изображение, в формат BMP. Функция выделяет память под новый массив pixelData, который содержит данные пикселей изображения в формате RGB. Затем она итерирует по элементам массива matrix, забирает значение каждого пикселя, и в зависимости от значения пикселя устанавливает соответствующие значения компонентам RGB в массиве pixelData. Если значение пикселя равно 1, то цвет пикселя в BMP-формате будет черным (RGB - 0,0,0), а если равно 0, то цвет будет белым (RGB - 255,255,255). Затем функция возвращает указатель на полученный массив pixelData.

Функция allocateArray выделяет память для двумерного массива array размером height * width. Она создает массив указателей на строки, а затем для каждой строки выделяет память для элементов.

В main прописываем основные операции игры «Жизнь». Программа открывает входное изображение, считывает информацию о размерах и смещении из заголовка BMP, а также считывает данные о цветах пикселей изображения. Далее программа создает два массива, представляющих текущее и следующее поколение клеток в игре. Затем она применяет правила игры "Жизнь" к текущему поколению и записывает измененные состояния в следующее поколение. После заданного количества итераций программа сохраняет состояние игры как изображение BMP с использованием функции fwrite(). Затем она освобождает выделенную динамическую память и завершает свою работу.

Пограничные случаи не учитываем, т.к. начинаем в цикле с 1, то есть на границах значения будет просто оставаться и потом пропадать.